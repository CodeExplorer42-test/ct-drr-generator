# -*- coding: utf-8 -*-
"""TCIA_Jupyter_Learning_Lab_2023.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/kirbyju/TCIA_Notebooks/blob/main/TCIA_Jupyter_Learning_Lab_2023.ipynb

You can download and run this notebook locally, or you can run it for free in a cloud environment using Colab or Sagemaker Studio Lab:

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/kirbyju/TCIA_Notebooks/blob/main/TCIA_Jupyter_Learning_Lab_2023.ipynb)

[![Open In SageMaker Studio Lab](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github.com/kirbyju/TCIA_Notebooks/blob/main/TCIA_Jupyter_Learning_Lab_2023.ipynb)

# Course Description

Access to large, high quality data is essential for researchers to understand disease and precision medicine pathways, especially in cancer. However HIPAA constraints make sharing medical images outside an individual institution a complex process. [The Cancer Imaging Archive (TCIA)](https://www.cancerimagingarchive.net/) TCIA is a public service funded by the National Cancer Institute which addresses this challenge by providing hosting and de-identification services to take major burdens of data sharing off researchers.

TCIA has published over 200 unique data collections containing more than 60 million images. Recognizing that images alone are not enough to conduct meaningful research, most collections are linked to rich supporting data including patient outcomes, treatment information, genomic / proteomic analyses, and expert image analyses (segmentations, annotations, and radiomic / radiogenomic features). **In this course we will address a variety of use cases for identifying TCIA datasets of interest and downloading them via Jupyter Notebooks.**

# Learning Objectives

* Learn how TCIA makes data sharing easier for researchers, and hear a summary of existing datsets that are freely available for download
* Practice utilizing TCIA for data exploration, cohort definition, and downloading of data
* Learn how to access public and restricted access datasets using TCIA's REST APIs and other command line tools via Google Colab

# 1 Learn about Available Collections on the TCIA Website

[Browsing Collections](https://www.cancerimagingarchive.net/collections) and viewing [Analysis Results](https://www.cancerimagingarchive.net/tcia-analysis-results/) of datasets on TCIA are the easiest ways to become familiar with what is available. These pages will help you quickly identify datasets of interest, find valuable supporting data that are not available via our APIs (e.g. clinical spreadsheets and non-DICOM segmentation data), and answer the most common questions you might have about the datasets.

# 2 Downloading with the NBIA Data Retriever

TCIA uses software called NBIA to manage its DICOM data.  One way to download TCIA data is to install the NBIA Data Retriever.  This tool provides a number of useful features such as auto-retry if there are any problems, saving data in an organized hierarchy on your hard drive (Collection > Patient > Study > Series > Images), and providing a CSV file containing key DICOM metadata about the images you've downloaded.

## 2.1 Install the NBIA Data Retriever
There are versions of this tool for Windows, Mac and Linux.  If you're working from a system with a GUI you can follow the [instructions](https://wiki.cancerimagingarchive.net/display/NBIA/Downloading+TCIA+Images) to install Data Retriever on your computer.

There is also a [command-line version of the NBIA Data Retriever](https://wiki.cancerimagingarchive.net/x/2QKPBQ) which can be installed via the steps below if you're running this notebook in a **Linux** environment.
"""

import sys
import requests
import pandas as pd

# Install tcia_utils
def install_requirements():
    import subprocess
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "-q", "tcia_utils"])
        print("tcia_utils installed successfully")
    except subprocess.CalledProcessError as e:
        print(f"Error installing tcia_utils: {e}")

# Install and import
install_requirements()

try:
    from tcia_utils import nbia
    print("tcia_utils imported successfully")
except ImportError as e:
    print(f"Error importing tcia_utils: {e}")
    print("Please run: pip install tcia_utils")

# Set up logging
import logging

# Set handler with level = info
logging.basicConfig(format='%(asctime)s:%(levelname)s:%(message)s',
                    level=logging.INFO)

print("Logging set to INFO")

def browse_collections():
    """Browse available collections and return as dataframe"""
    print("Getting list of available collections...")
    collections = nbia.getCollections(format="df")
    print(f"Found {len(collections)} collections")
    return collections

def find_chest_ct_collections(collections_df):
    """Find collections that might contain chest CT data"""
    print("\nSearching for chest CT collections...")
    
    # Look for chest-related keywords in collection names and descriptions
    chest_keywords = ['chest', 'lung', 'thorax', 'thoracic', 'nsclc', 'copd', 'pneumonia', 'covid']
    
    chest_collections = []
    
    for idx, row in collections_df.iterrows():
        collection_name = str(row['Collection']).lower()
        for keyword in chest_keywords:
            if keyword in collection_name:
                chest_collections.append(row['Collection'])
                print(f"Found chest-related collection: {row['Collection']}")
                break
    
    return chest_collections

def explore_collection_details(collection_name):
    """Get detailed information about a specific collection"""
    print(f"\nExploring collection: {collection_name}")
    
    # Get modality counts
    modalities = nbia.getModalityCounts(collection=collection_name, format="df")
    print("Available modalities:")
    print(modalities)
    
    # Get body part counts for CT
    if 'CT' in modalities['criteria'].values:
        body_parts = nbia.getBodyPartCounts(collection=collection_name, modality="CT", format="df")
        print(f"\nBody parts for CT in {collection_name}:")
        print(body_parts)
        
        # Look specifically for chest/thorax related body parts
        if 'BodyPartExamined' in body_parts.columns:
            chest_body_parts = body_parts[
                body_parts['BodyPartExamined'].str.contains('CHEST|THORAX|LUNG', case=False, na=False)
            ]
            
            if not chest_body_parts.empty:
                print(f"\nFound chest-related body parts:")
                print(chest_body_parts)
                return True
            else:
                print("No chest-specific body parts found, but may still contain chest CTs")
                return True
        else:
            print("Body part information not available, but collection has CT data")
            return True
    
    return False

def get_chest_ct_series(collection_name, limit=10):
    """Get chest CT series from a collection"""
    print(f"\nGetting chest CT series from {collection_name}...")
    
    # Try to get CT series
    try:
        series_data = nbia.getSeries(
            collection=collection_name,
            modality="CT",
            format="df"
        )
        
        if series_data.empty:
            print("No CT series found in this collection")
            return None
            
        print(f"Found {len(series_data)} CT series total")
        
        # Filter for chest-related series if possible
        chest_filters = []
        if 'BodyPartExamined' in series_data.columns:
            chest_filters.append(series_data['BodyPartExamined'].str.contains('CHEST|THORAX|LUNG', case=False, na=False))
        if 'SeriesDescription' in series_data.columns:
            chest_filters.append(series_data['SeriesDescription'].str.contains('CHEST|THORAX|LUNG', case=False, na=False))
        
        if chest_filters:
            chest_series = series_data[chest_filters[0] if len(chest_filters) == 1 else (chest_filters[0] | chest_filters[1])]
        else:
            chest_series = pd.DataFrame()
        
        if not chest_series.empty:
            print(f"Found {len(chest_series)} chest-specific CT series")
            return chest_series.head(limit)
        else:
            print("No chest-specific series found, returning general CT series")
            return series_data.head(limit)
            
    except Exception as e:
        print(f"Error getting series data: {e}")
        return None

def download_sample_chest_ct(series_data, num_series=1):
    """Download a sample of chest CT series"""
    if series_data is None or series_data.empty:
        print("No series data to download")
        return
        
    print(f"\nDownloading {num_series} sample chest CT series...")
    
    try:
        # Download the series
        df_result = nbia.downloadSeries(
            series_data, 
            input_type="df", 
            number=num_series, 
            format="df"
        )
        
        print("Download completed successfully!")
        print("Downloaded series details:")
        print(df_result[['PatientID', 'SeriesInstanceUID', 'SeriesDescription', 'Modality']])
        
        return df_result
        
    except Exception as e:
        print(f"Error downloading series: {e}")
        return None

def main():
    """Main function to browse and download chest CT"""
    print("=== TCIA Chest CT Browser ===")
    
    # Get all collections
    collections = browse_collections()
    
    # Find chest-related collections
    chest_collections = find_chest_ct_collections(collections)
    
    if not chest_collections:
        print("\nNo obvious chest collections found by name. Let's check some popular collections...")
        # Check some well-known collections that might have chest CTs
        popular_collections = ['LIDC-IDRI', 'LUNA16', 'NLST', 'NSCLC-Radiomics', 'COVID-19-NY-SBU']
        chest_collections = [col for col in popular_collections if col in collections['Collection'].values]
    
    if chest_collections:
        print(f"\nFound {len(chest_collections)} potential chest collections:")
        for i, collection in enumerate(chest_collections):
            print(f"{i+1}. {collection}")
        
        # Let's explore the first promising collection
        target_collection = chest_collections[0]
        print(f"\nExploring {target_collection}...")
        
        has_ct = explore_collection_details(target_collection)
        
        if has_ct:
            # Get chest CT series
            chest_series = get_chest_ct_series(target_collection, limit=5)
            
            if chest_series is not None:
                print(f"\nPreview of available chest CT series:")
                print(chest_series[['PatientID', 'SeriesDescription', 'BodyPartExamined']].head())
                
                # Ask user if they want to download
                print(f"\nWould you like to download a sample chest CT from {target_collection}?")
                response = input("Enter 'y' to download, or 'n' to skip: ").lower().strip()
                
                if response == 'y':
                    download_sample_chest_ct(chest_series, num_series=1)
                else:
                    print("Skipping download. You can call download_sample_chest_ct() later if needed.")
            
    else:
        print("No chest collections found. You may need to explore other collections manually.")

if __name__ == "__main__":
    main() 